{"version":3,"sources":["components/MyCard.js","components/Day.js","containers/Weather.js","redux/modules/weather.js","containers/Search.js","components/App.js","serviceWorker.js","redux/modules/reducer.js","config.js","index.js","api/state.js","api/metaWeather.js","redux/create.js"],"names":["MyCard","props","id","title","children","className","Day","data","date","temp","min","max","connect","state","pick","weather","isFetching","err","days","map","d","key","QUERY","SUGGEST","FETCH_ERROR","FETCHING","initState","search","locations","reducer","action","handler","fetchSuggestions","handleFetchSuccess","handleFetchError","hasOwnProperty","type","message","renderSuggestion","suggestion","timerId","mapDispatchToProps","updateQuery","dispatch","query","txt","_","api","then","onClearSuggestion","submit","locationId","getWeather","pipe","over","lensProp","moment","format","take","suggestions","onSuggestionsFetchRequested","value","clearTimeout","setTimeout","onSuggestionsClearRequested","getSuggestionValue","inputProps","placeholder","onChange","event","newValue","target","App","store","Boolean","window","location","hostname","match","createRootReducer","combineReducers","config","vendor","metaWeather","url","process","timeout","_window","storage","localStorage","get","getItem","JSON","parse","undefined","e","console","error","set","setItem","stringify","clear","removeItem","StateApi","http","client","create","baseURL","prop","loc","location_type","woeid","consolidated_weather","evolve","day","applicable_date","min_temp","max_temp","WeatherApi","axios","preloadedState","middleware","thunk","withExtraArgument","rootReducer","createStore","applyMiddleware","apply","configStore","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.45d213a1.chunk.js","sourcesContent":["import React from 'react';\nimport './MyCard.scss';\nimport PropTypes from 'prop-types';\n\nfunction MyCard(props) {\n  const { id, title, children } = props;\n  return (\n    <div className=\"mycard mycard--light\" id={`mycard--${id}`}>\n      <div className=\"mycard__title\">\n        <h2>{title}</h2>\n      </div>\n      <div className=\"mycard__body\">{children}</div>\n    </div>\n  );\n}\n\nMyCard.propTypes = {\n  id: PropTypes.string,\n  title: PropTypes.string,\n};\n\nexport default MyCard;\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport MyCard from './MyCard';\n\nexport function Day({ data }) {\n  return (\n    <MyCard title={data.date}>\n      <p>min: {data.temp.min}</p>\n      <p>max: {data.temp.max}</p>\n    </MyCard>\n  );\n}\n\nDay.propTypes = {\n  data: PropTypes.shape({\n    date: PropTypes.string,\n    temp: PropTypes.shape({\n      min: PropTypes.number,\n      max: PropTypes.number,\n    }),\n  }),\n};\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport { connect } from 'react-redux';\nimport { Day } from '../components/Day';\nimport { pick } from 'ramda';\nimport './Weather.scss';\n\nexport function Weather(props) {\n  return (\n    <section className=\"weather\">\n      {props.isFetching ? 'Loading' : null}\n      {props.err ? (\n        <div>{props.err}</div>\n      ) : (\n        props.days.map((d, id) => <Day key={id} data={d} />)\n      )}\n    </section>\n  );\n}\n\nWeather.propTypes = {\n  err: PropTypes.string,\n  isFetching: PropTypes.bool,\n  days: PropTypes.array,\n};\n\n/**\n * @param {RootState} state\n */\nfunction mapStateToProps(state) {\n  return pick(['err', 'days', 'isFetching'])(state.weather);\n}\n\nconst mapDispatchToProps = {};\n\nexport default connect(mapStateToProps, mapDispatchToProps)(Weather);\n","// Actions\nimport { lensProp, map, over, pipe, take } from 'ramda';\nimport moment from 'moment';\n\nexport const QUERY = 'ban/weather/QUERY';\nexport const SUGGEST = 'ban/weather/SUGGEST';\nexport const CLEAR_LOCATIONS = 'ban/weather/CLEAR_LOCATIONS';\nexport const FETCH_SUCCESS = 'ban/weather/FETCH_SUCCESS';\nexport const FETCH_ERROR = 'ban/weather/FETCH_ERROR';\nexport const FETCHING = 'ban/weather/FETCHING';\n\n// Reducer\n/**\n * @typedef {{search: string, locations: Array<MyLocationMeta>, isFetching: boolean, err: string, days: Array}} WeatherState\n */\nconst initState = {\n  search: '',\n  locations: [],\n  isFetching: false,\n  err: '',\n  days: [],\n};\n/**\n *\n * @param {WeatherState} state\n * @param {{type: string}} action\n * @return {WeatherState}\n */\nexport default function reducer(state = initState, action) {\n  const handler = {\n    [QUERY]: () => ({ ...state, search: action.search }),\n    [SUGGEST]: fetchSuggestions,\n    [CLEAR_LOCATIONS]: () => ({ ...state, locations: [] }),\n    [FETCHING]: () => ({ ...state, isFetching: true, err: '', days: [] }),\n    [FETCH_SUCCESS]: handleFetchSuccess,\n    [FETCH_ERROR]: handleFetchError,\n  };\n\n  return handler.hasOwnProperty(action.type) ? handler[action.type]() : state;\n\n  function fetchSuggestions() {\n    return {\n      ...state,\n      ...action.data,\n    };\n  }\n\n  function handleFetchSuccess() {\n    return {\n      ...state,\n      isFetching: false,\n      err: '',\n      days: action.data.weather,\n    };\n  }\n\n  function handleFetchError() {\n    return {\n      ...state,\n      isFetching: false,\n      err: action.err.message,\n      days: [],\n    };\n  }\n}\n\n// Action Creators\nexport function updateQuery(search) {\n  return dispatch => dispatch({ type: QUERY, search });\n}\nexport function query(txt) {\n  return function(dispatch, _, { api }) {\n    if (txt) {\n      api.weather.search(txt).then(\n        locations => dispatch({ type: SUGGEST, data: { locations } }),\n        () => dispatch({ type: SUGGEST, data: { locations: [] } })\n      );\n    }\n  };\n}\n\nexport function clearLocations() {\n  return dispatch => dispatch({ type: CLEAR_LOCATIONS });\n}\n\nexport function submit(locationId) {\n  return function(dispatch, _, { api }) {\n    dispatch({ type: FETCHING });\n    api.weather.getWeather(locationId).then(\n      pipe(\n        over(\n          lensProp('weather'),\n          pipe(\n            map(\n              over(lensProp('date'), date =>\n                moment(date, 'YYYY-MM-DD').format('dddd')\n              )\n            ),\n            take(5)\n          )\n        ),\n        data => dispatch({ type: FETCH_SUCCESS, data })\n      ),\n      err => dispatch({ type: FETCH_ERROR, err })\n    );\n  };\n}\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport { connect } from 'react-redux';\nimport Autosuggest from 'react-autosuggest';\nimport './Search.scss';\nimport {\n  clearLocations,\n  query,\n  updateQuery,\n  submit,\n} from '../redux/modules/weather';\n\nfunction renderSuggestion(suggestion) {\n  return <span>{suggestion.title}</span>;\n}\nlet timerId = null;\nexport function Search(props) {\n  function handleSuggestionClick(suggestion) {\n    props.submit(suggestion.id);\n    return suggestion.title;\n  }\n\n  // Suggestion is fetched after 1 second of idle\n  function handleFetchRequested({ value }) {\n    if (timerId) {\n      clearTimeout(timerId);\n    }\n    timerId = setTimeout(() => {\n      props.query(value);\n      timerId = null;\n    }, 1000);\n  }\n\n  function handleSelect(event, { newValue }) {\n    props.updateQuery(event.target.value || newValue);\n  }\n\n  return (\n    <section className=\"searcher\">\n      <Autosuggest\n        suggestions={props.locations}\n        onSuggestionsFetchRequested={handleFetchRequested}\n        onSuggestionsClearRequested={props.onClearSuggestion}\n        getSuggestionValue={handleSuggestionClick}\n        renderSuggestion={renderSuggestion}\n        inputProps={{\n          placeholder: 'Search',\n          value: props.txt,\n          onChange: handleSelect,\n        }}\n      />\n    </section>\n  );\n}\n\nSearch.propTypes = {\n  txt: PropTypes.string,\n  locations: PropTypes.array,\n  query: PropTypes.func,\n  updateQuery: PropTypes.func,\n  onClearSuggestion: PropTypes.func,\n  submit: PropTypes.func,\n};\n\n/**\n * @param {RootState} state\n */\nfunction mapStateToProps(state) {\n  return { txt: state.weather.search, locations: state.weather.locations };\n}\n\nconst mapDispatchToProps = {\n  updateQuery,\n  query,\n  onClearSuggestion: clearLocations,\n  submit,\n};\n\nexport default connect(mapStateToProps, mapDispatchToProps)(Search);\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport './App.scss';\nimport { Provider } from 'react-redux';\nimport Weather from '../containers/Weather';\nimport Search from '../containers/Search';\n\nexport default function App({ store }) {\n  return (\n    <Provider store={store}>\n      <div className=\"App App--light\">\n        <header>\n          <h1>Weather</h1>\n        </header>\n        <main>\n          <Search />\n          <Weather />\n        </main>\n      </div>\n    </Provider>\n  );\n}\n\nApp.propTypes = {\n  store: PropTypes.object,\n};\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import { combineReducers } from 'redux';\nimport weather from './weather';\n\n/**\n * @typedef {{weather: WeatherState}} RootState\n */\n\nfunction createRootReducer() {\n  return combineReducers({\n    weather,\n  });\n}\nexport default createRootReducer;\n","/**\n * @constant\n * @type {number} http request timeout in milliseconds\n */\nconst timeout = 60000;\n\n/**\n * @typedef AppConfig\n */\nconst config = {\n  vendor: {\n    metaWeather: {\n      url:\n        process.env.REACT_APP_METAWEATHER_URL || 'https://www.metaweather.com',\n      timeout,\n    },\n  },\n};\n\nexport default config;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport axios from 'axios';\nimport './index.scss';\nimport App from './components/App';\nimport * as serviceWorker from './serviceWorker';\nimport configStore from './redux/create';\nimport StateApi from './api/state';\nimport WeatherApi from './api/metaWeather';\nimport config from './config';\n\n// Bootstrap\n/**\n * @typedef {{state: stateApi, weather: weatherApi}} API\n * @type {API}\n */\nconst api = {\n  state: StateApi(window),\n  weather: WeatherApi(config.vendor.metaWeather, axios),\n};\nconst preloadedState = api.state.get();\nconst store = configStore(api, preloadedState);\n\n// Hooray\nReactDOM.render(<App store={store} />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","/**\n * @typedef {{set: function(Object), get: function: Object, clear: function}} stateApi\n */\n/**\n * State API constructor\n * @param {Window} _window\n * @return {stateApi}\n */\nexport default function StateApi(_window) {\n  const key = 'state';\n  /** @type {Storage} */\n  const storage = _window.localStorage;\n\n  function get() {\n    try {\n      const data = storage.getItem(key);\n      return data ? JSON.parse(data) : undefined;\n    } catch (e) {\n      _window.console.error(e);\n    }\n  }\n\n  function set(data) {\n    storage.setItem(key, JSON.stringify(data));\n  }\n\n  function clear() {\n    storage.removeItem(key);\n  }\n  return { get, set, clear };\n}\n","/**\n * @typedef {{search: locationSearch, getWeather: getWeather}} weatherApi\n */\nimport { evolve, map, pipe, prop } from 'ramda';\n\n/**\n * Weather API Constructor\n * @external AxiosStatic\n * @param {Object} config\n * @param {string} config.url\n * @param {number} config.timeout\n * @param {AxiosStatic} http\n * @return {weatherApi}\n */\nexport default function WeatherApi({ url, timeout }, http) {\n  const client = http.create({\n    baseURL: `${url}/api/location`,\n    timeout,\n  });\n\n  /**\n   * @typedef {{title: string, location_type: string, woeid: number}} LocationMeta\n   * @typedef {{title: string, type: string, id: number}} MyLocationMeta\n   */\n  /**\n   * @typedef locationSearch\n   * @param {string} txt\n   * @return {Promise<Array<MyLocationMeta>>}\n   */\n  function search(txt) {\n    return client.get(`/search?query=${txt}`).then(\n      pipe(\n        prop('data'),\n        map(loc => ({\n          title: loc.title,\n          type: loc.location_type,\n          id: loc.woeid,\n        }))\n      )\n    );\n  }\n\n  /**\n   * @typedef {{min_temp: number, max_temp: number, applicable_date: string}} DayWeather\n   * @typedef {{consolidated_weather: Array<DayWeather>}} LocationWeather\n   * @typedef {{temp: {min: number, max: number}, date: string}} MyDayWeather\n   * @typedef {{weather: Array<MyDayWeather>}} MyLocationWeather\n   */\n  /**\n   * @typedef getWeather\n   * @param {string|number} locationId\n   * @return {Promise<MyLocationWeather>}\n   */\n  function getWeather(locationId) {\n    return client.get(`/${locationId}`).then(\n      pipe(\n        prop('data'),\n        data => ({ weather: data.consolidated_weather }),\n        evolve({\n          weather: map(day => ({\n            date: day.applicable_date,\n            temp: { min: day.min_temp, max: day.max_temp },\n          })),\n        })\n      )\n    );\n  }\n\n  return {\n    search,\n    getWeather,\n  };\n}\n","import { applyMiddleware, createStore } from 'redux';\nimport thunk from 'redux-thunk';\nimport createRootReducer from './modules/reducer';\n\n/**\n * Create redux store with preloadedState\n * @param api\n * @param preloadedState\n * @returns {Object}\n */\nexport default function configStore(api, preloadedState) {\n  const middleware = [thunk.withExtraArgument({ api })];\n  const rootReducer = createRootReducer();\n\n  return createStore(\n    rootReducer,\n    preloadedState,\n    applyMiddleware.apply(null, middleware)\n  );\n}\n"],"sourceRoot":""}