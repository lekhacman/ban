{"version":3,"sources":["components/MyCard.js","components/Day.js","containers/Weather.js","redux/modules/weather.js","containers/Search.js","components/App.js","serviceWorker.js","redux/modules/reducer.js","config.js","index.js","api/state.js","api/metaWeather.js","redux/create.js"],"names":["MyCard","props","id","title","children","className","Day","data","date","temp","min","max","connect","state","pick","weather","isFetching","err","days","map","d","key","QUERY","SUGGEST","FETCH_ERROR","FETCHING","initState","search","locations","reducer","action","handler","handleQuery","handleFetchSuccess","handleFetchError","hasOwnProperty","type","message","renderSuggestion","suggestion","mapDispatchToProps","onSearch","dispatch","onQuery","txt","getState","api","then","onClearSuggestion","onSubmit","locationId","getWeather","pipe","over","lensProp","moment","format","take","suggestions","onSuggestionsFetchRequested","value","onSuggestionsClearRequested","getSuggestionValue","inputProps","placeholder","onChange","event","newValue","target","App","store","Boolean","window","location","hostname","match","createRootReducer","combineReducers","config","vendor","metaWeather","url","process","timeout","_window","storage","localStorage","get","getItem","JSON","parse","undefined","e","console","error","set","setItem","stringify","clear","removeItem","StateApi","http","client","create","baseURL","prop","loc","location_type","woeid","consolidated_weather","evolve","day","applicable_date","min_temp","max_temp","WeatherApi","axios","preloadedState","middleware","thunk","withExtraArgument","rootReducer","createStore","applyMiddleware","apply","configStore","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.07ff1cb1.chunk.js","sourcesContent":["import React from 'react';\nimport './MyCard.scss';\nimport PropTypes from 'prop-types';\n\nfunction MyCard(props) {\n  const { id, title, children } = props;\n  return (\n    <div className=\"mycard mycard--light\" id={`mycard--${id}`}>\n      <div className=\"mycard__title\">\n        <h2>{title}</h2>\n      </div>\n      <div className=\"mycard__body\">{children}</div>\n    </div>\n  );\n}\n\nMyCard.propTypes = {\n  id: PropTypes.string,\n  title: PropTypes.string,\n};\n\nexport default MyCard;\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport MyCard from './MyCard';\n\nexport function Day({ data }) {\n  return (\n    <MyCard title={data.date}>\n      <div>min: {data.temp.min}</div>\n      <div>max: {data.temp.max}</div>\n    </MyCard>\n  );\n}\n\nDay.propTypes = {\n  data: PropTypes.shape({\n    date: PropTypes.string,\n    temp: PropTypes.shape({\n      min: PropTypes.number,\n      max: PropTypes.number,\n    }),\n  }),\n};\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport { connect } from 'react-redux';\nimport { Day } from '../components/Day';\nimport { pick } from 'ramda';\n\nexport function Weather(props) {\n  return (\n    <div>\n      {props.isFetching ? 'Loading' : null}\n      {props.err\n        ? props.err\n        : props.days.map((d, id) => <Day key={id} data={d} />)}\n    </div>\n  );\n}\n\nWeather.propTypes = {\n  err: PropTypes.string,\n  isFetching: PropTypes.bool,\n  days: PropTypes.array,\n};\n\n/**\n * @param {RootState} state\n */\nfunction mapStateToProps(state) {\n  return pick(['err', 'days', 'isFetching'])(state.weather);\n}\n\nconst mapDispatchToProps = {};\n\nexport default connect(mapStateToProps, mapDispatchToProps)(Weather);\n","// Actions\nimport { evolve, lensProp, map, over, pipe, take } from 'ramda';\nimport moment from 'moment';\n\nexport const QUERY = 'ban/weather/QUERY';\nexport const SUGGEST = 'ban/weather/SUGGEST';\nexport const CLEAR_LOCATIONS = 'ban/weather/CLEAR_LOCATIONS';\nexport const FETCH_SUCCESS = 'ban/weather/FETCH_SUCCESS';\nexport const FETCH_ERROR = 'ban/weather/FETCH_ERROR';\nexport const FETCHING = 'ban/weather/FETCHING';\n\n// Reducer\n/**\n * @typedef {{search: string, locations: Array<MyLocationMeta>, isFetching: boolean, err: string, days: Array}} WeatherState\n */\nconst initState = {\n  search: '',\n  locations: [],\n  isFetching: false,\n  err: '',\n  days: [],\n};\n/**\n *\n * @param {WeatherState} state\n * @param {{type: string}} action\n * @return {WeatherState}\n */\nexport default function reducer(state = initState, action) {\n  const handler = {\n    [QUERY]: () => ({ ...state, search: action.search }),\n    [SUGGEST]: handleQuery,\n    [CLEAR_LOCATIONS]: () => ({ ...state, locations: [] }),\n    [FETCHING]: () => ({ ...state, isFetching: true, err: '' }),\n    [FETCH_SUCCESS]: handleFetchSuccess,\n    [FETCH_ERROR]: handleFetchError,\n  };\n\n  return handler.hasOwnProperty(action.type) ? handler[action.type]() : state;\n\n  function handleQuery() {\n    return {\n      ...state,\n      ...action.data,\n    };\n  }\n\n  function handleFetchSuccess() {\n    return {\n      ...state,\n      isFetching: false,\n      err: '',\n      days: action.data.weather,\n    };\n  }\n\n  function handleFetchError() {\n    return {\n      ...state,\n      isFetching: false,\n      err: action.err.message,\n      days: [],\n    };\n  }\n}\n\n// Action Creators\nexport function search(search) {\n  return dispatch => dispatch({ type: QUERY, search });\n}\nexport function query(txt) {\n  return function(dispatch, getState, { api }) {\n    if (txt) {\n      api.weather.search(txt).then(\n        locations =>\n          dispatch({ type: SUGGEST, data: { search: txt, locations } }),\n        () => dispatch({ type: SUGGEST, data: { search: txt, locations: [] } })\n      );\n    }\n  };\n}\n\nexport function clearLocations() {\n  return dispatch => dispatch({ type: CLEAR_LOCATIONS });\n}\n\nexport function submit(locationId) {\n  return function(dispatch, getState, { api }) {\n    dispatch({ type: FETCHING });\n    api.weather.getWeather(locationId).then(\n      pipe(\n        over(\n          lensProp('weather'),\n          pipe(\n            map(\n              over(lensProp('date'), date =>\n                moment(date, 'YYYY-MM-DD').format('dddd')\n              )\n            ),\n            take(5)\n          )\n        ),\n        data => dispatch({ type: FETCH_SUCCESS, data })\n      ),\n      err => dispatch({ type: FETCH_ERROR, err })\n    );\n  };\n}\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport { connect } from 'react-redux';\n// import { Field, Form, Formik } from 'formik';\nimport Autosuggest from 'react-autosuggest';\nimport {\n  clearLocations,\n  query,\n  search,\n  submit,\n} from '../redux/modules/weather';\n\nfunction renderSuggestion(suggestion) {\n  return <div>{suggestion.title}</div>;\n}\n\nexport function Search(props) {\n  // function query(fOnChange, event) {\n  //   props.onQuery(event.target.value);\n  //   fOnChange(event);\n  // }\n  // return (\n  //   <Formik initialValues={{ txt: props.txt }} onSubmit={props.onSubmit}>\n  //     <Form>\n  //       <div>\n  //         <Field name=\"txt\">\n  //           {function({ field }) {\n  //             return (\n  //               <div>\n  //                 <input\n  //                   type=\"text\"\n  //                   placeholder=\"Search\"\n  //                   onChange={query.bind(null, field.onChange)}\n  //                 />\n  //               </div>\n  //             );\n  //           }}\n  //         </Field>\n  //         <button type=\"submit\">Search</button>\n  //       </div>\n  //     </Form>\n  //   </Formik>\n  // );\n\n  function getSuggestionValue(suggestion) {\n    props.onSubmit(suggestion.id);\n    return suggestion.title;\n  }\n\n  function handleFetchRequested({ value }) {\n    props.onQuery(value);\n  }\n\n  function handleSelect(event, { newValue }) {\n    props.onSearch(event.target.value || newValue);\n  }\n\n  return (\n    <div>\n      {/*<input type=\"text\" placeholder=\"Search\" onChange={handleQuery} />*/}\n      <Autosuggest\n        suggestions={props.locations}\n        onSuggestionsFetchRequested={handleFetchRequested}\n        onSuggestionsClearRequested={props.onClearSuggestion}\n        getSuggestionValue={getSuggestionValue}\n        renderSuggestion={renderSuggestion}\n        inputProps={{\n          placeholder: 'Search',\n          value: props.txt,\n          onChange: handleSelect,\n        }}\n      />\n    </div>\n  );\n}\n\nSearch.propTypes = {\n  txt: PropTypes.string,\n  locations: PropTypes.array,\n  onQuery: PropTypes.func,\n  onSearch: PropTypes.func,\n  onClearSuggestion: PropTypes.func,\n  onSubmit: PropTypes.func,\n};\n\n/**\n * @param {RootState} state\n */\nfunction mapStateToProps(state) {\n  return { txt: state.weather.search, locations: state.weather.locations };\n}\n\nconst mapDispatchToProps = {\n  onSearch: search,\n  onQuery: query,\n  onClearSuggestion: clearLocations,\n  onSubmit: submit,\n};\n\nexport default connect(mapStateToProps, mapDispatchToProps)(Search);\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport './App.scss';\nimport { Provider } from 'react-redux';\nimport Weather from '../containers/Weather';\nimport Search from '../containers/Search';\n\nexport default function App({ store }) {\n  return (\n    <Provider store={store}>\n      <div className=\"App App--light\">\n        <header>\n          <h1>Weather</h1>\n        </header>\n        <main>\n          <Search />\n          <Weather />\n        </main>\n      </div>\n    </Provider>\n  );\n}\n\nApp.propTypes = {\n  store: PropTypes.object,\n};\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import { combineReducers } from 'redux';\nimport weather from './weather';\n\n/**\n * @typedef {{weather: WeatherState}} RootState\n */\n\nfunction createRootReducer() {\n  return combineReducers({\n    weather,\n  });\n}\nexport default createRootReducer;\n","/**\n * @constant\n * @type {number} http request timeout in milliseconds\n */\nconst timeout = 60000;\n\n/**\n * @typedef AppConfig\n */\nconst config = {\n  vendor: {\n    metaWeather: {\n      url:\n        process.env.REACT_APP_METAWEATHER_URL || 'https://www.metaweather.com',\n      timeout,\n    },\n  },\n};\n\nexport default config;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport axios from 'axios';\nimport './index.scss';\nimport App from './components/App';\nimport * as serviceWorker from './serviceWorker';\nimport configStore from './redux/create';\nimport StateApi from './api/state';\nimport WeatherApi from './api/metaWeather';\nimport config from './config';\n\n// Bootstrap\n/**\n * @typedef {{state: stateApi, weather: weatherApi}} API\n * @type {API}\n */\nconst api = {\n  state: StateApi(window),\n  weather: WeatherApi(config.vendor.metaWeather, axios),\n};\nconst preloadedState = api.state.get();\nconst store = configStore(api, preloadedState);\n\n// Hooray\nReactDOM.render(<App store={store} />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","/**\n * @typedef {{set: function(Object), get: function: Object, clear: function}} stateApi\n */\n/**\n * State API constructor\n * @param {Window} _window\n * @return {stateApi}\n */\nexport default function StateApi(_window) {\n  const key = 'state';\n  /** @type {Storage} */\n  const storage = _window.localStorage;\n\n  function get() {\n    try {\n      const data = storage.getItem(key);\n      return data ? JSON.parse(data) : undefined;\n    } catch (e) {\n      _window.console.error(e);\n    }\n  }\n\n  function set(data) {\n    storage.setItem(key, JSON.stringify(data));\n  }\n\n  function clear() {\n    storage.removeItem(key);\n  }\n  return { get, set, clear };\n}\n","/**\n * @typedef {{search: locationSearch, getWeather: getWeather}} weatherApi\n */\nimport { evolve, map, pipe, prop } from 'ramda';\n\n/**\n * Weather API Constructor\n * @external AxiosStatic\n * @param {Object} config\n * @param {string} config.url\n * @param {number} config.timeout\n * @param {AxiosStatic} http\n * @return {weatherApi}\n */\nexport default function WeatherApi({ url, timeout }, http) {\n  const client = http.create({\n    baseURL: `${url}/api/location`,\n    timeout,\n  });\n\n  /**\n   * @typedef {{title: string, location_type: string, woeid: number}} LocationMeta\n   * @typedef {{title: string, type: string, id: number}} MyLocationMeta\n   */\n  /**\n   * @typedef locationSearch\n   * @param {string} txt\n   * @return {Promise<Array<MyLocationMeta>>}\n   */\n  function search(txt) {\n    return client.get(`/search?query=${txt}`).then(\n      pipe(\n        prop('data'),\n        map(loc => ({\n          title: loc.title,\n          type: loc.location_type,\n          id: loc.woeid,\n        }))\n      )\n    );\n  }\n\n  /**\n   * @typedef {{min_temp: number, max_temp: number, applicable_date: string}} DayWeather\n   * @typedef {{consolidated_weather: Array<DayWeather>}} LocationWeather\n   * @typedef {{temp: {min: number, max: number}, date: string}} MyDayWeather\n   * @typedef {{weather: Array<MyDayWeather>}} MyLocationWeather\n   */\n  /**\n   * @typedef getWeather\n   * @param {string|number} locationId\n   * @return {Promise<MyLocationWeather>}\n   */\n  function getWeather(locationId) {\n    return client.get(`/${locationId}`).then(\n      pipe(\n        prop('data'),\n        data => ({ weather: data.consolidated_weather }),\n        evolve({\n          weather: map(day => ({\n            date: day.applicable_date,\n            temp: { min: day.min_temp, max: day.max_temp },\n          })),\n        })\n      )\n    );\n  }\n\n  return {\n    search,\n    getWeather,\n  };\n}\n","import { applyMiddleware, createStore } from 'redux';\nimport thunk from 'redux-thunk';\nimport createRootReducer from './modules/reducer';\n\n/**\n * Create redux store with preloadedState\n * @param api\n * @param preloadedState\n * @returns {Object}\n */\nexport default function configStore(api, preloadedState) {\n  const middleware = [thunk.withExtraArgument({ api })];\n  const rootReducer = createRootReducer();\n\n  return createStore(\n    rootReducer,\n    preloadedState,\n    applyMiddleware.apply(null, middleware)\n  );\n}\n"],"sourceRoot":""}